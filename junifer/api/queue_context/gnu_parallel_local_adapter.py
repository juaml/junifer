"""Define concrete class for generating GNU Parallel (local) assets."""

# Authors: Synchon Mandal <s.mandal@fz-juelich.de>
# License: AGPL

import shutil
import textwrap
from pathlib import Path
from typing import Any, Optional

from ...typing import Elements
from ...utils import logger, make_executable, run_ext_cmd
from .queue_context_adapter import (
    EnvKind,
    EnvShell,
    QueueContextAdapter,
    QueueContextEnv,
)


__all__ = ["GnuParallelLocalAdapter"]


class GnuParallelLocalAdapter(QueueContextAdapter):
    """Class for generating commands for GNU Parallel (local).

    Parameters
    ----------
    job_name : str
        The job name.
    job_dir : pathlib.Path
        The path to the job directory.
    yaml_config_path : pathlib.Path
        The path to the YAML config file.
    elements : Elements
        Element(s) to process. Will be used to index the DataGrabber.
    pre_run_cmds : str or None, optional
        Extra shell commands to source before the run (default None).
    pre_collect_cmds : str or None, optional
        Extra shell commands to source before the collect (default None).
    env : :class:`.QueueContextEnv` or None, optional
        The environment configuration. If None, will run without a
        virtual environment of any kind (default None).
    verbose : str, optional
        The level of verbosity (default "info").
    verbose_datalad : str or None, optional
        The level of verbosity for datalad. If None, will be the same
        as ``verbose`` (default None).
    submit : bool, optional
        Whether to submit the jobs (default False).

    See Also
    --------
    QueueContextAdapter :
        The base class for QueueContext.
    HTCondorAdapter :
        The concrete class for queueing via HTCondor.

    """

    job_name: str
    job_dir: Path
    yaml_config_path: Path
    elements: Elements
    pre_run_cmds: Optional[str] = None
    pre_collect_cmds: Optional[str] = None
    env: Optional[QueueContextEnv] = None
    verbose: str = "info"
    verbose_datalad: Optional[str] = None
    submit: bool = False

    def model_post_init(self, context: Any):  # noqa: D102
        if self.env is None:
            self.env = QueueContextEnv(
                kind=EnvKind.Local, shell=EnvShell.Bash, name=""
            )
        if self.env["kind"] == EnvKind.Local:
            # No virtual environment
            self._executable = "junifer"
            self._arguments = ""
        else:
            self._executable = f"run_{self.env['kind']}.{self.env['shell']}"
            self._arguments = f"{self.env['name']} junifer"
            self._exec_path = self.job_dir / self._executable
        self._log_dir = self.job_dir / "logs"
        self._pre_run_path = self.job_dir / "pre_run.sh"
        self._pre_collect_path = self.job_dir / "pre_collect.sh"
        self._run_path = self.job_dir / f"run_{self.job_name}.sh"
        self._collect_path = self.job_dir / f"collect_{self.job_name}.sh"
        self._run_joblog_path = self.job_dir / f"run_{self.job_name}_joblog"
        self._elements_file_path = self.job_dir / "elements"

    def elements_to_run(self) -> str:
        """Return elements to run."""
        elements_to_run = []
        for element in self.elements:
            # Stringify elements if tuple for operation
            str_element = (
                ",".join(element) if isinstance(element, tuple) else element
            )
            elements_to_run.append(str_element)

        return "\n".join(elements_to_run)

    def pre_run(self) -> str:
        """Return pre-run commands."""
        fixed = (
            f"#!/usr/bin/env {self.env['shell']}\n\n"
            "# This script is auto-generated by junifer.\n\n"
            "# Force datalad to run in non-interactive mode\n"
            "DATALAD_UI_INTERACTIVE=false\n"
        )
        var = self.pre_run_cmds or ""
        return fixed + "\n" + var

    def run(self) -> str:
        """Return run commands."""
        verbose_args = f"--verbose {self.verbose}"
        if self.verbose_datalad:
            verbose_args = (
                f"{verbose_args} --verbose-datalad {self.verbose_datalad}"
            )
        return (
            f"#!/usr/bin/env {self.env['shell']}\n\n"
            "# This script is auto-generated by junifer.\n\n"
            "# Run pre_run.sh\n"
            f"sh {self._pre_run_path.resolve()!s}\n\n"
            "# Run `junifer run` using `parallel`\n"
            "parallel --bar --resume --resume-failed "
            f"--joblog {self._run_joblog_path} "
            "--delay 60 "  # wait 1 min before next job is spawned
            f"--results {self._log_dir} "
            f"--arg-file {self._elements_file_path.resolve()!s} "
            f"{self.job_dir.resolve()!s}/{self._executable} "
            f"{self._arguments} run "
            f"{self.yaml_config_path.resolve()!s} "
            f"{verbose_args} "
            f"--element"
        )

    def pre_collect(self) -> str:
        """Return pre-collect commands."""
        fixed = (
            f"#!/usr/bin/env {self.env['shell']}\n\n"
            "# This script is auto-generated by junifer.\n"
        )
        var = self.pre_collect_cmds or ""
        return fixed + "\n" + var

    def collect(self) -> str:
        """Return collect commands."""
        verbose_args = f"--verbose {self.verbose}"
        if self.verbose_datalad:
            verbose_args = (
                f"{verbose_args} --verbose-datalad {self.verbose_datalad}"
            )
        return (
            f"#!/usr/bin/env {self.env['shell']}\n\n"
            "# This script is auto-generated by junifer.\n\n"
            "# Run pre_collect.sh\n"
            f"sh {self._pre_collect_path.resolve()!s}\n\n"
            "# Run `junifer collect`\n"
            f"{self.job_dir.resolve()!s}/{self._executable} "
            f"{self._arguments} collect "
            f"{self.yaml_config_path.resolve()!s} "
            f"{verbose_args}"
        )

    def prepare(self) -> None:
        """Prepare assets for submission."""
        logger.info("Preparing for local queue via GNU parallel")
        # Copy executable if not local
        if hasattr(self, "_exec_path"):
            logger.info(
                f"Copying {self._executable} to {self._exec_path.resolve()!s}"
            )
            shutil.copy(
                src=Path(__file__).parent.parent / "res" / self._executable,
                dst=self._exec_path,
            )
            make_executable(self._exec_path)
        # Create elements file
        logger.info(
            f"Writing {self._elements_file_path.name} to "
            f"{self._elements_file_path.resolve()!s}"
        )
        self._elements_file_path.touch()
        self._elements_file_path.write_text(
            textwrap.dedent(self.elements_to_run())
        )
        # Create pre run
        logger.info(
            f"Writing {self._pre_run_path.name} to {self.job_dir.resolve()!s}"
        )
        self._pre_run_path.touch()
        self._pre_run_path.write_text(textwrap.dedent(self.pre_run()))
        make_executable(self._pre_run_path)
        # Create run
        logger.info(
            f"Writing {self._run_path.name} to {self.job_dir.resolve()!s}"
        )
        self._run_path.touch()
        self._run_path.write_text(textwrap.dedent(self.run()))
        make_executable(self._run_path)
        # Create pre collect
        logger.info(
            f"Writing {self._pre_collect_path.name} to "
            f"{self.job_dir.resolve()!s}"
        )
        self._pre_collect_path.touch()
        self._pre_collect_path.write_text(textwrap.dedent(self.pre_collect()))
        make_executable(self._pre_collect_path)
        # Create collect
        logger.info(
            f"Writing {self._collect_path.name} to {self.job_dir.resolve()!s}"
        )
        self._collect_path.touch()
        self._collect_path.write_text(textwrap.dedent(self.collect()))
        make_executable(self._collect_path)
        # Submit if required
        run_cmd = f"sh {self._run_path.resolve()!s}"
        collect_cmd = f"sh {self._collect_path.resolve()!s}"
        if self.submit:
            logger.info(
                "Shell scripts created, the following will be run:\n"
                f"{run_cmd}\n"
                "After successful completion of the previous step, run:\n"
                f"{collect_cmd}"
            )
            run_ext_cmd(name=f"{self._run_path.resolve()!s}", cmd=[run_cmd])
        else:
            logger.info(
                "Shell scripts created, to start, run:\n"
                f"{run_cmd}\n"
                "After successful completion of the previous step, run:\n"
                f"{collect_cmd}"
            )
